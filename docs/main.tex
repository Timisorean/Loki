\documentclass[]{article}

\usepackage{amsmath}
\usepackage{syntax}

\title{Grammar Definition}
\author{Dominik Drexler}
\date{\today}

\newcommand{\plus}{\textsuperscript{+}}
\newcommand{\typing}{\textsuperscript{:typing}~}
\newcommand{\fluents}{\textsuperscript{:fluents}~}
\newcommand{\negativepreconditions}{\textsuperscript{:negative-preconditions}~}
\newcommand{\disjunctivepreconditions}{\textsuperscript{:disjunctive-preconditions}~}
\newcommand{\existentialpreconditions}{\textsuperscript{:existential-preconditions}~}
\newcommand{\universalpreconditions}{\textsuperscript{:universal-preconditions}~}
\newcommand{\conditionaleffects}{\textsuperscript{:conditional-effects}~}

\begin{document}
\maketitle

\section{Domain}

% https://tex.stackexchange.com/questions/24886/which-package-can-be-used-to-write-bnf-grammars
\begin{grammar}


    <digit> ::= 0..9

    <letter> ::= a..z | A..Z

    <any char> ::= <letter> | <digit> | - | _

    <name> ::= <letter> <any char>*

    <variable> ::= ?<name>

    <number> ::= digit\plus . digit*   %% TODO int or float



    <type> ::= <name> | ( either <type>\plus ) | ( fluent <type> )

    <type> ::= ( <type> )

    <typed list (x)> ::= x*

    <typed list (x)> ::= x\plus - <type> <typed list (x)>


    <predicate> ::= <name>

    <atomic formula skeleton> ::= ( <predicate> <typed list (variable)> )



    <function symbol> ::= <name>

    <function type> ::= <digit>

    <atomic function skeleton> ::= ( <function symbol> <typed list (variable)> )

    <function typed list (x)> ::= x*

    <function typed list (x)> ::= x\plus - <function type> <function typed list (x)>


    <atomic formular (t)> ::= ( <predicate> t* )

    <atom> ::= <atomic formula (term)>

    <negated atom> ::= ( not <atomic formula (term)> )

    <literal> ::= <atom> | <negated atom>


    <require-def> ::= :strip | :typing

    <types-def> ::= ( :types <typed list (name)> )

    <constants-def> ::= ( :constants <typed list (name)> )

    <predicates-def> ::= ( :predicates <atomic formula skeleton>* )

    <functions-def> ::= ( :functions <function typed list (atomic function skeleton)> )

    <domain> ::= ( define ( domain <name> )\newline
    [<require-def>] \newline
    [<types-def>] \newline
    [<constants-def>] \newline
    [<predicates-def>] )

\end{grammar}

\section{Actions}

\begin{grammar}
    <GD atom> ::= <atom>

    <GD literal> ::=\negativepreconditions{} <literal>

    <GD and> ::=  ( and <GD>* )

    <GD or> ::=\disjunctivepreconditions{} ( or <GD>* )

    <GD not> ::=\disjunctivepreconditions{} ( not <GD>* )

    <GD imply> ::=\disjunctivepreconditions{} ( imply <GD> <GD> )

    <GD exists> ::=\existentialpreconditions{} ( exists <typed list (variable)> <GD> )

    <GD forall> ::=\universalpreconditions{} ( forall <typed list (variable)> <GD> )

    <GD> ::= <GD atom> | <GD literal> | <GD and> | <GD or> | <GD not> | <GD imply> | <GD exists> | <GD forall>


    <effect> ::= ( and <cond-effect>* ) | <cond-effect>

    <cond-effect-forall> ::=\conditionaleffects ( forall ( <typed list (variable)>* ) <effect> )

    <cond-effect-when> ::=\conditionaleffects ( when <GD> <leaf-cond-effect> )

    <cond-effect> ::= <cond-effect-forall> | <cond-effect-when> | <simple-effect>

    <simple-effect-literal> ::= <literal>

    <simple-effect-fluent> ::=\fluents ( <assign-op> <f-head> <f-exp> )

    <simple-effect> ::= <simple-effect-literal> | <simple-effect-fluent>

    <leaf-cond-effect> ::= ( and <simple-effect>* ) | <simple-effect>
\end{grammar}

\nocite{mcdermott-et-al-1998}

\bibliographystyle{plain}
\bibliography{refs}

\end{document}